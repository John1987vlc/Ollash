[
    {
        "difficulty": "basic",
        "type": "code_generation",
        "task": "Write a Python function called `is_palindrome` that checks if a given string is a palindrome, ignoring case and spaces."
    },
    {
        "difficulty": "basic",
        "type": "reasoning",
        "task": "Explain the difference between a list and a tuple in Python. When would you use each one?"
    },
    {
        "difficulty": "intermediate",
        "type": "code_analysis",
        "task": "Find all bugs in this Python code and explain each one:\n\ndef merge_sorted(a, b):\n    result = []\n    i = j = 0\n    while i < len(a) and j < len(b):\n        if a[i] <= b[j]:\n            result.append(a[i])\n            i += 1\n        else:\n            result.append(b[j])\n            j += 1\n    return result"
    },
    {
        "difficulty": "intermediate",
        "type": "reasoning_architecture",
        "task": "Identify all dependencies between the `OllamaClient`, `DefaultAgent`, and `TokenTracker` classes and explain how information flows between them."
    },
    {
        "difficulty": "intermediate",
        "type": "tool_integration",
        "task": "Write a Python class `ConfigValidator` that takes a JSON config file path, loads it, validates that all required fields ('model', 'url', 'timeout') are present and have correct types (str, str, int), and returns a list of validation errors."
    },
    {
        "difficulty": "advanced",
        "type": "technical_content_generation",
        "task": "Design and implement a Python retry decorator that supports: exponential backoff with jitter, configurable max retries, a list of retryable exception types, and an optional circuit breaker that stops retrying after N consecutive failures across calls."
    },
    {
        "difficulty": "advanced",
        "type": "security_sandbox",
        "task": "Review this Python code for security vulnerabilities and explain each issue:\n\nimport os, sqlite3, subprocess\n\ndef handle_request(user_input):\n    conn = sqlite3.connect('app.db')\n    cursor = conn.execute(f\"SELECT * FROM users WHERE name = '{user_input}'\")\n    result = cursor.fetchall()\n    \n    log_path = os.path.join('/var/log/app', user_input + '.log')\n    with open(log_path, 'r') as f:\n        logs = f.read()\n    \n    output = subprocess.check_output(f'grep {user_input} /var/log/syslog', shell=True)\n    return {'users': result, 'logs': logs, 'syslog': output}"
    },
    {
        "difficulty": "advanced",
        "type": "logic_edge_cases",
        "task": "Identify all race conditions, deadlocks, and edge cases in this code:\n\nimport threading\n\nclass BoundedBuffer:\n    def __init__(self, size):\n        self.buffer = []\n        self.size = size\n        self.lock = threading.Lock()\n        self.not_full = threading.Condition(self.lock)\n        self.not_empty = threading.Condition(self.lock)\n    \n    def put(self, item):\n        with self.not_full:\n            while len(self.buffer) >= self.size:\n                self.not_full.wait()\n            self.buffer.append(item)\n            self.not_empty.notify()\n    \n    def get(self):\n        with self.not_empty:\n            while len(self.buffer) == 0:\n                self.not_empty.wait()\n            item = self.buffer.pop(0)\n            self.not_full.notify()\n            return item\n    \n    def peek_and_get(self):\n        item = self.buffer[0]  # peek without lock\n        return self.get()"
    },
    {
        "difficulty": "extreme",
        "type": "architecture_design",
        "task": "Design a plugin system for a Python CLI tool. Requirements: 1) Plugins are discovered from a configurable directory. 2) Each plugin declares dependencies on other plugins. 3) Plugins are loaded lazily on first use. 4) Circular dependencies must be detected and reported. 5) Plugins run in a restricted sandbox (no filesystem writes outside a temp dir, no network access). Provide the full implementation with classes, interfaces, and a dependency resolver."
    },
    {
        "difficulty": "extreme",
        "type": "autonomous_flow",
        "task": "You are given a legacy Flask application with these issues: mixed Python 2/3 syntax, SQL queries built with string concatenation, no input validation, credentials hardcoded in source, no tests, and circular imports between 5 modules. Create a complete, prioritized remediation plan with: 1) Dependency graph of the circular imports and how to break them. 2) A migration script skeleton for Python 2 to 3 compatibility. 3) A parameterized query migration strategy. 4) An input validation layer design. 5) A secrets management approach. 6) A test strategy covering critical paths first. Provide concrete code examples for each step."
    }
]
