"""
Security Scan Phase

Runs VulnerabilityScanner on generated files, produces a security report,
generates Dependabot configuration, and optionally blocks on critical findings.
"""

import subprocess
from pathlib import Path
from typing import Any, Dict, List, Tuple

from backend.agents.auto_agent_phases.phase_context import PhaseContext
from backend.interfaces.iagent_phase import IAgentPhase


class SecurityScanPhase(IAgentPhase):
    """
    Scans generated files for security vulnerabilities.

    - Runs VulnerabilityScanner on all code files
    - Generates SECURITY_SCAN_REPORT.md
    - Optionally blocks project if critical vulnerabilities found
    - Posts scan report as PR comment (if enabled)
    """

    def __init__(self, context: PhaseContext):
        self.context = context

    async def execute(
        self,
        project_description: str,
        project_name: str,
        project_root: Path,
        readme_content: str,
        initial_structure: Dict[str, Any],
        generated_files: Dict[str, str],
        **kwargs: Any,
    ) -> Tuple[Dict[str, str], Dict[str, Any], List[str]]:
        file_paths = kwargs.get("file_paths", [])
        block_on_critical = kwargs.get("block_security_critical", False)

        if not self.context.vulnerability_scanner:
            self.context.logger.warning("Security Scan: Skipped (VulnerabilityScanner not available)")
            return generated_files, initial_structure, file_paths

        self.context.logger.info("PHASE SECURITY: Starting security scan...")
        self.context.event_publisher.publish(
            "phase_start", phase="security_scan", message="Scanning for vulnerabilities"
        )

        # Run scanner on all code files
        code_files = {
            path: content for path, content in generated_files.items() if content and self._is_scannable(path)
        }

        scan_report = self.context.vulnerability_scanner.scan_project(code_files, block_on_critical=False)

        self.context.logger.info(
            f"  Scan results: {scan_report.total_vulnerabilities} vulnerabilities "
            f"(critical={scan_report.critical_count}, high={scan_report.high_count}, "
            f"medium={scan_report.medium_count}, low={scan_report.low_count})"
        )

        # Write scan report
        report_content = self._format_scan_report(scan_report, project_name)
        generated_files["SECURITY_SCAN_REPORT.md"] = report_content
        self.context.file_manager.write_file(project_root / "SECURITY_SCAN_REPORT.md", report_content)
        if "SECURITY_SCAN_REPORT.md" not in file_paths:
            file_paths.append("SECURITY_SCAN_REPORT.md")

        self.context.event_publisher.publish(
            "tool_output",
            tool_name="security_scan",
            total_vulnerabilities=scan_report.total_vulnerabilities,
            critical=scan_report.critical_count,
            high=scan_report.high_count,
            blocked_files=scan_report.blocked_files,
        )

        # Generate dependabot config based on detected ecosystems
        dependabot_config = self._generate_dependabot_from_files(generated_files)
        if dependabot_config:
            github_dir = project_root / ".github"
            github_dir.mkdir(parents=True, exist_ok=True)
            # Only write if not already generated by InfrastructureGenerationPhase
            if ".github/dependabot.yml" not in generated_files:
                generated_files[".github/dependabot.yml"] = dependabot_config
                self.context.file_manager.write_file(github_dir / "dependabot.yml", dependabot_config)
                if ".github/dependabot.yml" not in file_paths:
                    file_paths.append(".github/dependabot.yml")

        # Optionally post as PR comment
        if kwargs.get("security_scan_as_pr") and kwargs.get("git_token"):
            self._publish_scan_as_pr_comment(project_root, scan_report)

        # Block on critical if configured
        if block_on_critical and scan_report.critical_count > 0:
            self.context.logger.error(f"SECURITY SCAN: {scan_report.critical_count} CRITICAL vulnerabilities found!")
            self.context.event_publisher.publish(
                "phase_complete",
                phase="security_scan",
                message=f"BLOCKED: {scan_report.critical_count} critical vulnerabilities",
                status="error",
            )
            # Don't raise - let the pipeline continue but log prominently
            generated_files["SECURITY_BLOCKED.md"] = (
                f"# Security Scan Blocked\n\n"
                f"{scan_report.critical_count} critical vulnerabilities were detected.\n"
                f"See SECURITY_SCAN_REPORT.md for details.\n"
            )
            self.context.file_manager.write_file(
                project_root / "SECURITY_BLOCKED.md",
                generated_files["SECURITY_BLOCKED.md"],
            )
        else:
            self.context.event_publisher.publish(
                "phase_complete",
                phase="security_scan",
                message="Security scan complete",
                status="success",
            )

        return generated_files, initial_structure, file_paths

    def _is_scannable(self, path: str) -> bool:
        """Check if file should be scanned for vulnerabilities."""
        scannable_extensions = {
            ".py",
            ".js",
            ".jsx",
            ".ts",
            ".tsx",
            ".go",
            ".rs",
            ".java",
        }
        return Path(path).suffix.lower() in scannable_extensions

    def _format_scan_report(self, report, project_name: str) -> str:
        """Format scan report as Markdown."""
        lines = [
            f"# Security Scan Report — {project_name}\n",
            f"**Files scanned:** {report.files_scanned}/{report.total_files}",
            f"**Total vulnerabilities:** {report.total_vulnerabilities}\n",
            "## Severity Breakdown\n",
            "| Severity | Count |",
            "|----------|-------|",
            f"| Critical | {report.critical_count} |",
            f"| High     | {report.high_count} |",
            f"| Medium   | {report.medium_count} |",
            f"| Low      | {report.low_count} |",
            f"| Info     | {report.info_count} |",
            "",
        ]

        if report.blocked_files:
            lines.append("## Blocked Files\n")
            for bf in report.blocked_files:
                lines.append(f"- `{bf}`")
            lines.append("")

        # Detail per file
        for result in report.file_results:
            if not result.vulnerabilities:
                continue
            lines.append(f"## {result.file_path}\n")
            for vuln in result.vulnerabilities:
                lines.append(
                    f"- **[{vuln.severity.upper()}]** {vuln.description} (line {vuln.line_number}) — {vuln.rule_id}"
                )
                if vuln.fix_suggestion:
                    lines.append(f"  - Fix: {vuln.fix_suggestion}")
            lines.append("")

        return "\n".join(lines)

    def _generate_dependabot_from_files(self, generated_files: Dict[str, str]) -> str:
        """Generate Dependabot config from detected package files."""
        file_names = {Path(fp).name for fp in generated_files}
        ecosystems = []

        if "requirements.txt" in file_names or "pyproject.toml" in file_names:
            ecosystems.append("pip")
        if "package.json" in file_names:
            ecosystems.append("npm")
        if "go.mod" in file_names:
            ecosystems.append("gomod")
        if "Cargo.toml" in file_names:
            ecosystems.append("cargo")
        if "Gemfile" in file_names:
            ecosystems.append("bundler")

        if not ecosystems:
            return ""

        updates = []
        for eco in ecosystems:
            updates.append(
                f'  - package-ecosystem: "{eco}"\n'
                f'    directory: "/"\n'
                f"    schedule:\n"
                f'      interval: "weekly"\n'
                f"    open-pull-requests-limit: 10"
            )

        return f"version: 2\nupdates:\n{chr(10).join(updates)}\n"

    def _publish_scan_as_pr_comment(self, project_root: Path, scan_report) -> None:
        """Post scan report as a PR comment via gh CLI."""
        try:
            summary = (
                f"## Security Scan Results\n\n"
                f"- **Critical:** {scan_report.critical_count}\n"
                f"- **High:** {scan_report.high_count}\n"
                f"- **Medium:** {scan_report.medium_count}\n"
                f"- **Low:** {scan_report.low_count}\n\n"
                f"Total: {scan_report.total_vulnerabilities} vulnerabilities "
                f"in {scan_report.files_scanned} files."
            )

            subprocess.run(
                ["gh", "pr", "comment", "--body", summary],
                capture_output=True,
                text=True,
                cwd=str(project_root),
                timeout=15,
            )
        except Exception as e:
            self.context.logger.debug(f"Could not post scan as PR comment: {e}")
