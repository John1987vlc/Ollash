"""
Real-Time Vulnerability Scanner

AST-based and pattern-matching scanner that detects insecure code patterns
during the CodeQuarantine phase and blocks generation on critical findings.
"""

import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from backend.utils.core.agent_logger import AgentLogger


@dataclass
class Vulnerability:
    """A detected vulnerability in generated code."""

    severity: str  # "info", "low", "medium", "high", "critical"
    rule_id: str
    description: str
    line_number: int
    code_snippet: str
    cwe_id: Optional[str] = None
    fix_suggestion: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "severity": self.severity,
            "rule_id": self.rule_id,
            "description": self.description,
            "line_number": self.line_number,
            "code_snippet": self.code_snippet,
            "cwe_id": self.cwe_id,
            "fix_suggestion": self.fix_suggestion,
        }


@dataclass
class ScanResult:
    """Result of scanning a single file."""

    file_path: str
    language: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scan_time_ms: float = 0.0

    @property
    def has_critical(self) -> bool:
        return any(v.severity == "critical" for v in self.vulnerabilities)

    @property
    def has_high(self) -> bool:
        return any(v.severity in ("critical", "high") for v in self.vulnerabilities)

    @property
    def max_severity(self) -> str:
        severity_order = {"info": 0, "low": 1, "medium": 2, "high": 3, "critical": 4}
        if not self.vulnerabilities:
            return "info"
        return max(self.vulnerabilities, key=lambda v: severity_order.get(v.severity, 0)).severity

    def to_dict(self) -> Dict[str, Any]:
        return {
            "file_path": self.file_path,
            "language": self.language,
            "vulnerability_count": len(self.vulnerabilities),
            "max_severity": self.max_severity,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
        }


@dataclass
class ProjectScanReport:
    """Aggregated scan report for an entire project."""

    total_files: int
    files_scanned: int
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    info_count: int
    blocked_files: List[str]
    file_results: List[ScanResult]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "total_files": self.total_files,
            "files_scanned": self.files_scanned,
            "total_vulnerabilities": self.total_vulnerabilities,
            "severity_counts": {
                "critical": self.critical_count,
                "high": self.high_count,
                "medium": self.medium_count,
                "low": self.low_count,
                "info": self.info_count,
            },
            "blocked_files": self.blocked_files,
            "file_results": [r.to_dict() for r in self.file_results if r.vulnerabilities],
        }


# --- Security Rules ---

SECURITY_RULES: List[Dict[str, Any]] = [
    # SQL Injection
    {
        "rule_id": "SEC-001",
        "name": "SQL Injection via string formatting",
        "severity": "critical",
        "cwe_id": "CWE-89",
        "languages": ["python"],
        "patterns": [
            r'(?:execute|cursor\.execute)\s*\(\s*[f"\'].*\{.*\}',
            r'(?:execute|cursor\.execute)\s*\(\s*["\'].*%s.*["\'].*%',
            r"(?:execute|cursor\.execute)\s*\(\s*.*\+\s*(?:request|input|user)",
        ],
        "fix": "Use parameterized queries: cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))",
    },
    {
        "rule_id": "SEC-001b",
        "name": "SQL Injection via concatenation",
        "severity": "critical",
        "cwe_id": "CWE-89",
        "languages": ["javascript", "typescript"],
        "patterns": [
            r'(?:query|execute)\s*\(\s*[`"\'].*\$\{',
            r"(?:query|execute)\s*\(\s*.*\+\s*(?:req\.|input|user)",
        ],
        "fix": "Use parameterized queries with placeholders",
    },
    # Command Injection
    {
        "rule_id": "SEC-002",
        "name": "Command Injection",
        "severity": "critical",
        "cwe_id": "CWE-78",
        "languages": ["python"],
        "patterns": [
            r'os\.system\s*\(\s*[f"\'].*\{',
            r'subprocess\.(?:call|run|Popen)\s*\(\s*[f"\'].*\{',
            r'os\.popen\s*\(\s*[f"\'].*\{',
            r"eval\s*\(\s*(?:request|input|user)",
            r"exec\s*\(\s*(?:request|input|user)",
        ],
        "fix": "Use subprocess with list arguments and shlex.quote() for user input",
    },
    {
        "rule_id": "SEC-002b",
        "name": "Command Injection",
        "severity": "critical",
        "cwe_id": "CWE-78",
        "languages": ["javascript", "typescript"],
        "patterns": [
            r'child_process\.exec\s*\(\s*[`"\'].*\$\{',
            r"eval\s*\(\s*(?:req\.|input|user)",
        ],
        "fix": "Use child_process.execFile() with separate arguments",
    },
    # Hardcoded Secrets
    {
        "rule_id": "SEC-003",
        "name": "Hardcoded secret/credential",
        "severity": "high",
        "cwe_id": "CWE-798",
        "languages": ["python", "javascript", "typescript", "go", "rust", "java"],
        "patterns": [
            r'(?:password|passwd|pwd|secret|api_key|apikey|token|auth_token)\s*=\s*["\'][^"\']{8,}["\']',
            r'(?:AWS_SECRET|PRIVATE_KEY|DATABASE_URL)\s*=\s*["\'][^"\']+["\']',
        ],
        "fix": "Use environment variables or a secrets manager instead of hardcoded values",
    },
    # XSS
    {
        "rule_id": "SEC-004",
        "name": "Cross-Site Scripting (XSS)",
        "severity": "high",
        "cwe_id": "CWE-79",
        "languages": ["python"],
        "patterns": [
            r"render_template_string\s*\(",
            r'Markup\s*\(\s*[f"\'].*\{',
            r"\.format\s*\(.*request\.",
        ],
        "fix": "Use Jinja2 auto-escaping and avoid render_template_string with user input",
    },
    {
        "rule_id": "SEC-004b",
        "name": "Cross-Site Scripting (XSS)",
        "severity": "high",
        "cwe_id": "CWE-79",
        "languages": ["javascript", "typescript"],
        "patterns": [
            r'\.innerHTML\s*=\s*(?![\s]*["\'])',
            r"document\.write\s*\(",
            r"dangerouslySetInnerHTML",
        ],
        "fix": "Use textContent instead of innerHTML, or sanitize with DOMPurify",
    },
    # Unsafe Deserialization
    {
        "rule_id": "SEC-005",
        "name": "Unsafe deserialization",
        "severity": "high",
        "cwe_id": "CWE-502",
        "languages": ["python"],
        "patterns": [
            r"pickle\.loads?\s*\(",
            r"yaml\.load\s*\(\s*[^)]*(?!Loader\s*=\s*yaml\.SafeLoader)",
            r"marshal\.loads?\s*\(",
        ],
        "fix": "Use json instead of pickle, or yaml.safe_load() instead of yaml.load()",
    },
    # Path Traversal
    {
        "rule_id": "SEC-006",
        "name": "Path Traversal",
        "severity": "high",
        "cwe_id": "CWE-22",
        "languages": ["python", "javascript", "typescript"],
        "patterns": [
            r"open\s*\(\s*(?:request|input|user)",
            r"os\.path\.join\s*\(\s*.*(?:request|input|user)",
            r"fs\.(?:readFile|writeFile|readdir)\s*\(\s*(?:req\.|input|user)",
        ],
        "fix": "Validate and sanitize file paths; use os.path.realpath() to resolve symlinks",
    },
    # SSRF
    {
        "rule_id": "SEC-007",
        "name": "Server-Side Request Forgery (SSRF)",
        "severity": "medium",
        "cwe_id": "CWE-918",
        "languages": ["python"],
        "patterns": [
            r"requests\.(?:get|post|put|delete)\s*\(\s*(?:request|input|user)",
            r"urllib\.request\.urlopen\s*\(\s*(?:request|input|user)",
        ],
        "fix": "Validate and whitelist URLs before making server-side requests",
    },
    # Weak Cryptography
    {
        "rule_id": "SEC-008",
        "name": "Weak cryptographic algorithm",
        "severity": "medium",
        "cwe_id": "CWE-327",
        "languages": ["python", "javascript", "typescript"],
        "patterns": [
            r"(?:hashlib\.)?md5\s*\(",
            r"(?:hashlib\.)?sha1\s*\(",
            r"DES\s*\.",
            r'createCipher\s*\(\s*["\'](?:des|rc4)',
        ],
        "fix": "Use SHA-256 or stronger hashing; use AES-256 for encryption",
    },
    # Debug/Dev in Production
    {
        "rule_id": "SEC-009",
        "name": "Debug mode in production",
        "severity": "medium",
        "cwe_id": "CWE-489",
        "languages": ["python"],
        "patterns": [
            r"app\.run\s*\(.*debug\s*=\s*True",
            r"DEBUG\s*=\s*True",
        ],
        "fix": "Set debug=False in production; use environment variables for configuration",
    },
    # Insecure Random
    {
        "rule_id": "SEC-010",
        "name": "Insecure random number generation",
        "severity": "low",
        "cwe_id": "CWE-330",
        "languages": ["python"],
        "patterns": [
            r"random\.(random|randint|choice|shuffle)\s*\(",
        ],
        "fix": "Use secrets module for security-sensitive random values",
    },
]

# Language extension mapping
LANGUAGE_MAP = {
    ".py": "python",
    ".js": "javascript",
    ".jsx": "javascript",
    ".ts": "typescript",
    ".tsx": "typescript",
    ".go": "go",
    ".rs": "rust",
    ".java": "java",
}


class VulnerabilityScanner:
    """Scans generated code for security vulnerabilities using pattern matching.

    Integrates with the CodeQuarantine phase to block files with critical
    vulnerabilities from being included in the generated project.
    """

    def __init__(self, logger: AgentLogger, custom_rules: Optional[List[Dict]] = None):
        self.logger = logger
        self.rules = SECURITY_RULES + (custom_rules or [])

    def scan_file(self, file_path: str, content: str, language: str = "") -> ScanResult:
        """Scan a single file for vulnerabilities."""
        import time

        start = time.time()

        if not language:
            from pathlib import Path

            ext = Path(file_path).suffix.lower()
            language = LANGUAGE_MAP.get(ext, "")

        vulnerabilities = []
        lines = content.split("\n")

        for rule in self.rules:
            if language and language not in rule.get("languages", []):
                continue

            for pattern_str in rule.get("patterns", []):
                try:
                    pattern = re.compile(pattern_str, re.IGNORECASE)
                    for line_num, line in enumerate(lines, 1):
                        if pattern.search(line):
                            vulnerabilities.append(
                                Vulnerability(
                                    severity=rule["severity"],
                                    rule_id=rule["rule_id"],
                                    description=rule["name"],
                                    line_number=line_num,
                                    code_snippet=line.strip()[:200],
                                    cwe_id=rule.get("cwe_id"),
                                    fix_suggestion=rule.get("fix", ""),
                                )
                            )
                except re.error:
                    continue

        elapsed = (time.time() - start) * 1000

        result = ScanResult(
            file_path=file_path,
            language=language,
            vulnerabilities=vulnerabilities,
            scan_time_ms=elapsed,
        )

        if vulnerabilities:
            self.logger.info(
                f"Found {len(vulnerabilities)} vulnerabilities in {file_path} (max severity: {result.max_severity})"
            )

        return result

    def scan_project(self, files: Dict[str, str], block_on_critical: bool = True) -> ProjectScanReport:
        """Scan all files in a project."""
        results = []
        blocked = []
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}

        for file_path, content in files.items():
            result = self.scan_file(file_path, content)
            results.append(result)

            for v in result.vulnerabilities:
                severity_counts[v.severity] = severity_counts.get(v.severity, 0) + 1

            if block_on_critical and result.has_critical:
                blocked.append(file_path)

        total_vulns = sum(severity_counts.values())

        report = ProjectScanReport(
            total_files=len(files),
            files_scanned=len(results),
            total_vulnerabilities=total_vulns,
            critical_count=severity_counts["critical"],
            high_count=severity_counts["high"],
            medium_count=severity_counts["medium"],
            low_count=severity_counts["low"],
            info_count=severity_counts["info"],
            blocked_files=blocked,
            file_results=results,
        )

        self.logger.info(f"Project scan: {total_vulns} vulnerabilities in {len(files)} files, {len(blocked)} blocked")

        return report
