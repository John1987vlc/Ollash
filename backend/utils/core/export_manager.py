"""
Multi-Purpose Export Manager

Handles exporting generated projects to various targets:
zip archives, GitHub/GitLab repositories, cloud deployments.
"""

import shutil
from pathlib import Path
from typing import Any, Dict, Optional

from backend.utils.core.agent_logger import AgentLogger
from backend.utils.core.command_executor import CommandExecutor


class ExportManager:
    """Manages project export to various deployment targets."""

    def __init__(self, command_executor: CommandExecutor, logger: AgentLogger):
        self.command_executor = command_executor
        self.logger = logger

    def export_zip(self, project_root: Path, output_dir: Optional[Path] = None) -> Path:
        """Export project as a ZIP archive."""
        project_name = project_root.name
        output_dir = output_dir or project_root.parent
        output_path = output_dir / f"{project_name}.zip"

        shutil.make_archive(
            str(output_path).replace(".zip", ""),
            "zip",
            root_dir=str(project_root.parent),
            base_dir=project_name,
        )

        self.logger.info(f"Exported ZIP: {output_path}")
        return output_path

    async def deploy_to_github(
        self,
        project_root: Path,
        repo_name: str,
        token: str,
        private: bool = True,
        organization: Optional[str] = None,
    ) -> str:
        """Deploy project to a new GitHub repository.

        Requires gh CLI or git with token auth.
        """
        self.logger.info(f"Deploying to GitHub: {repo_name}")

        # Initialize git repo if needed
        git_dir = project_root / ".git"
        if not git_dir.exists():
            self.command_executor.execute("git init", cwd=str(project_root))
            self.command_executor.execute("git add -A", cwd=str(project_root))
            self.command_executor.execute(
                'git commit -m "Initial commit - Generated by Ollash"',
                cwd=str(project_root),
            )

        # Create remote repo using gh CLI
        visibility = "--private" if private else "--public"
        org_flag = f"--org {organization}" if organization else ""

        result = self.command_executor.execute(
            f"gh repo create {repo_name} {visibility} {org_flag} --source=. --push",
            cwd=str(project_root),
            env={"GH_TOKEN": token},
        )

        if result.get("returncode") == 0:
            repo_url = f"https://github.com/{organization or 'user'}/{repo_name}"
            self.logger.info(f"Deployed to GitHub: {repo_url}")
            return repo_url
        else:
            # Fallback: manual git push
            remote_url = f"https://{token}@github.com/{organization or 'user'}/{repo_name}.git"
            self.command_executor.execute(f"git remote add origin {remote_url}", cwd=str(project_root))
            self.command_executor.execute("git push -u origin main", cwd=str(project_root))
            return remote_url

    async def deploy_to_gitlab(
        self,
        project_root: Path,
        repo_name: str,
        token: str,
        private: bool = True,
        namespace: Optional[str] = None,
    ) -> str:
        """Deploy project to a new GitLab repository."""
        self.logger.info(f"Deploying to GitLab: {repo_name}")

        # Initialize git repo if needed
        if not (project_root / ".git").exists():
            self.command_executor.execute("git init", cwd=str(project_root))
            self.command_executor.execute("git add -A", cwd=str(project_root))
            self.command_executor.execute(
                'git commit -m "Initial commit - Generated by Ollash"',
                cwd=str(project_root),
            )

        ns = namespace or "user"
        remote_url = f"https://oauth2:{token}@gitlab.com/{ns}/{repo_name}.git"

        self.command_executor.execute(f"git remote add origin {remote_url}", cwd=str(project_root))
        self.command_executor.execute("git push -u origin main", cwd=str(project_root))

        repo_url = f"https://gitlab.com/{ns}/{repo_name}"
        self.logger.info(f"Deployed to GitLab: {repo_url}")
        return repo_url

    async def deploy_to_cloud(self, project_root: Path, provider: str, config: Dict[str, Any]) -> str:
        """Deploy to a cloud provider.

        Supports basic deployment via CLI tools (if installed):
        - AWS: aws/cdk/sam
        - GCP: gcloud
        - Azure: az
        - Vercel: vercel
        - Railway: railway
        - Render: render
        """
        self.logger.info(f"Deploying to cloud: {provider}")

        deploy_commands = {
            "vercel": "vercel --yes --prod",
            "railway": "railway up",
            "render": "render deploy",
            "fly": "fly deploy",
            "heroku": "git push heroku main",
        }

        cmd = deploy_commands.get(provider)
        if not cmd:
            self.logger.warning(f"Unsupported cloud provider: {provider}")
            return f"Deployment to {provider} not yet supported"

        env = {}
        if config.get("token"):
            env_key = f"{provider.upper()}_TOKEN"
            env[env_key] = config["token"]

        result = self.command_executor.execute(cmd, cwd=str(project_root), env=env, timeout=300)

        if result.get("returncode") == 0:
            output = result.get("stdout", "")
            self.logger.info(f"Cloud deployment successful: {provider}")
            return output
        else:
            error = result.get("stderr", "Unknown error")
            self.logger.error(f"Cloud deployment failed: {error}")
            return f"Deployment failed: {error}"

    def get_supported_targets(self) -> Dict[str, str]:
        """Return supported export targets and descriptions."""
        return {
            "zip": "Download as ZIP archive",
            "github": "Push to GitHub repository",
            "gitlab": "Push to GitLab repository",
            "vercel": "Deploy to Vercel",
            "railway": "Deploy to Railway",
            "fly": "Deploy to Fly.io",
        }
