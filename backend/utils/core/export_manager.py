"""
Multi-Purpose Export Manager

Handles exporting generated projects to various targets:
zip archives, GitHub/GitLab repositories, cloud deployments.
"""

import shutil
from pathlib import Path
from typing import Any, Dict, List, Optional

from backend.utils.core.agent_logger import AgentLogger
from backend.utils.core.command_executor import CommandExecutor


class ExportManager:
    """Manages project export to various deployment targets."""

    def __init__(self, command_executor: CommandExecutor, logger: AgentLogger):
        self.command_executor = command_executor
        self.logger = logger

    def export_zip(self, project_root: Path, output_dir: Optional[Path] = None) -> Path:
        """Export project as a ZIP archive."""
        project_name = project_root.name
        output_dir = output_dir or project_root.parent
        output_path = output_dir / f"{project_name}.zip"

        shutil.make_archive(
            str(output_path).replace(".zip", ""),
            "zip",
            root_dir=str(project_root.parent),
            base_dir=project_name,
        )

        self.logger.info(f"Exported ZIP: {output_path}")
        return output_path

    async def deploy_to_github(
        self,
        project_root: Path,
        repo_name: str,
        token: str,
        private: bool = True,
        organization: Optional[str] = None,
    ) -> str:
        """Deploy project to a new GitHub repository.

        Requires gh CLI or git with token auth.
        """
        self.logger.info(f"Deploying to GitHub: {repo_name}")

        # Initialize git repo if needed
        git_dir = project_root / ".git"
        if not git_dir.exists():
            self.command_executor.execute("git init", cwd=str(project_root))
            self.command_executor.execute("git add -A", cwd=str(project_root))
            self.command_executor.execute(
                'git commit -m "Initial commit - Generated by Ollash"',
                cwd=str(project_root),
            )

        # Create remote repo using gh CLI
        visibility = "--private" if private else "--public"
        org_flag = f"--org {organization}" if organization else ""

        result = self.command_executor.execute(
            f"gh repo create {repo_name} {visibility} {org_flag} --source=. --push",
            cwd=str(project_root),
            env={"GH_TOKEN": token},
        )

        if result.get("returncode") == 0:
            repo_url = f"https://github.com/{organization or 'user'}/{repo_name}"
            self.logger.info(f"Deployed to GitHub: {repo_url}")
            return repo_url
        else:
            # Fallback: manual git push
            remote_url = f"https://{token}@github.com/{organization or 'user'}/{repo_name}.git"
            self.command_executor.execute(f"git remote add origin {remote_url}", cwd=str(project_root))
            self.command_executor.execute("git push -u origin main", cwd=str(project_root))
            return remote_url

    async def deploy_to_gitlab(
        self,
        project_root: Path,
        repo_name: str,
        token: str,
        private: bool = True,
        namespace: Optional[str] = None,
    ) -> str:
        """Deploy project to a new GitLab repository."""
        self.logger.info(f"Deploying to GitLab: {repo_name}")

        # Initialize git repo if needed
        if not (project_root / ".git").exists():
            self.command_executor.execute("git init", cwd=str(project_root))
            self.command_executor.execute("git add -A", cwd=str(project_root))
            self.command_executor.execute(
                'git commit -m "Initial commit - Generated by Ollash"',
                cwd=str(project_root),
            )

        ns = namespace or "user"
        remote_url = f"https://oauth2:{token}@gitlab.com/{ns}/{repo_name}.git"

        self.command_executor.execute(f"git remote add origin {remote_url}", cwd=str(project_root))
        self.command_executor.execute("git push -u origin main", cwd=str(project_root))

        repo_url = f"https://gitlab.com/{ns}/{repo_name}"
        self.logger.info(f"Deployed to GitLab: {repo_url}")
        return repo_url

    async def deploy_to_cloud(self, project_root: Path, provider: str, config: Dict[str, Any]) -> str:
        """Deploy to a cloud provider.

        Supports basic deployment via CLI tools (if installed):
        - AWS: aws/cdk/sam
        - GCP: gcloud
        - Azure: az
        - Vercel: vercel
        - Railway: railway
        - Render: render
        """
        self.logger.info(f"Deploying to cloud: {provider}")

        deploy_commands = {
            "vercel": "vercel --yes --prod",
            "railway": "railway up",
            "render": "render deploy",
            "fly": "fly deploy",
            "heroku": "git push heroku main",
        }

        cmd = deploy_commands.get(provider)
        if not cmd:
            self.logger.warning(f"Unsupported cloud provider: {provider}")
            return f"Deployment to {provider} not yet supported"

        env = {}
        if config.get("token"):
            env_key = f"{provider.upper()}_TOKEN"
            env[env_key] = config["token"]

        result = self.command_executor.execute(cmd, cwd=str(project_root), env=env, timeout=300)

        if result.get("returncode") == 0:
            output = result.get("stdout", "")
            self.logger.info(f"Cloud deployment successful: {provider}")
            return output
        else:
            error = result.get("stderr", "Unknown error")
            self.logger.error(f"Cloud deployment failed: {error}")
            return f"Deployment failed: {error}"

    async def initialize_wiki(
        self,
        project_root: Path,
        doc_files: Dict[str, str],
        repo_owner: str,
        repo_name: str,
        token: str,
    ) -> bool:
        """Initialize GitHub Wiki and create pages from documentation files."""
        if not repo_owner or not repo_name:
            self.logger.warning("Wiki init skipped: missing repo owner/name")
            return False

        self.logger.info(f"Initializing wiki with {len(doc_files)} pages...")

        wiki_url = f"https://{token}@github.com/{repo_owner}/{repo_name}.wiki.git"
        wiki_dir = project_root / ".wiki_temp"

        try:
            self.command_executor.execute(f"git clone {wiki_url} {wiki_dir}", cwd=str(project_root), timeout=30)

            for doc_path, content in doc_files.items():
                page_name = Path(doc_path).stem.replace("_", "-")
                wiki_file = wiki_dir / f"{page_name}.md"
                wiki_file.parent.mkdir(parents=True, exist_ok=True)
                wiki_file.write_text(content, encoding="utf-8")

            self.command_executor.execute("git add -A", cwd=str(wiki_dir))
            self.command_executor.execute(
                'git commit -m "docs: Initialize wiki from generated documentation"',
                cwd=str(wiki_dir),
            )
            result = self.command_executor.execute("git push -u origin master", cwd=str(wiki_dir), timeout=30)

            shutil.rmtree(wiki_dir, ignore_errors=True)

            success = result.get("returncode") == 0
            if success:
                self.logger.info("Wiki initialized successfully")
            return success

        except Exception as e:
            self.logger.warning(f"Wiki initialization failed: {e}")
            shutil.rmtree(wiki_dir, ignore_errors=True)
            return False

    def setup_github_pages(self, docs_dir: str = ".") -> str:
        """Return a GitHub Pages deployment workflow YAML."""
        return f"""name: Deploy Documentation to GitHub Pages

on:
  push:
    branches: [main]
    paths:
      - 'docs/**'
      - '*.md'
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{{{ steps.deployment.outputs.page_url }}}}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v4
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: '{docs_dir}'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
"""

    def generate_badges(
        self,
        project_name: str,
        repo_owner: str,
        workflows: Optional[List[str]] = None,
    ) -> str:
        """Generate markdown badges for CI, security, license."""
        if not repo_owner:
            return ""

        badges = []

        badges.append(f"![CI](https://github.com/{repo_owner}/{project_name}/actions/workflows/ci.yml/badge.svg)")
        badges.append(
            f"![Deploy](https://github.com/{repo_owner}/{project_name}/actions/workflows/deploy.yml/badge.svg)"
        )
        badges.append("![Security](https://img.shields.io/badge/security-scanned-green)")
        badges.append(f"![License](https://img.shields.io/github/license/{repo_owner}/{project_name})")

        return " ".join(badges)

    def get_supported_targets(self) -> Dict[str, str]:
        """Return supported export targets and descriptions."""
        return {
            "zip": "Download as ZIP archive",
            "github": "Push to GitHub repository",
            "gitlab": "Push to GitLab repository",
            "vercel": "Deploy to Vercel",
            "railway": "Deploy to Railway",
            "fly": "Deploy to Fly.io",
            "wiki": "Initialize GitHub Wiki",
            "pages": "Setup GitHub Pages",
        }
